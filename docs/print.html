<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Azure AD Workload Identity</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="installation.html">Installation</a></li><li class="chapter-item expanded affix "><a href="quick-start.html">Quick Start</a></li><li class="chapter-item expanded affix "><a href="concepts.html">Concepts</a></li><li class="chapter-item expanded "><a href="topics.html"><strong aria-hidden="true">1.</strong> Topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topics/managed-clusters.html"><strong aria-hidden="true">1.1.</strong> Managed Clusters</a></li><li class="chapter-item expanded "><a href="topics/self-managed-clusters.html"><strong aria-hidden="true">1.2.</strong> Self-Managed Clusters</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.2.1.</strong> Service Account Key Generation</div></li><li class="chapter-item expanded "><a href="topics/self-managed-clusters/service-account-key-rotation.html"><strong aria-hidden="true">1.2.2.</strong> Service Account Key Rotation</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.2.3.</strong> OIDC Endpoints</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.2.3.1.</strong> Discovery Endpoint</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.2.3.2.</strong> JSON Web Key (JWK) Endpoint</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.2.4.</strong> Configurations</div></li></ol></li><li class="chapter-item expanded "><a href="topics/service-account-labels-and-annotations.html"><strong aria-hidden="true">1.3.</strong> Service Account Labels And Annotations</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.4.</strong> Language-Specific Examples</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Troubleshooting</div></li><li class="chapter-item expanded "><a href="known-issues.html"><strong aria-hidden="true">3.</strong> Known Issues</a></li><li class="chapter-item expanded "><a href="development.html"><strong aria-hidden="true">4.</strong> Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/releasing.html"><strong aria-hidden="true">4.1.</strong> Releasing</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">5.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="code-of-conduct.html"><strong aria-hidden="true">6.</strong> Code of Conduct</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Azure AD Workload Identity</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/Azure/azure-workload-identity" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Azure AD Workload Identity is the next iteration of <a href="https://github.com/Azure/aad-pod-identity">AAD Pod Identity</a> that enables Kubernetes applications to access Azure cloud resources securely with <a href="https://azure.microsoft.com/en-us/services/active-directory/">Azure Active Directory</a> based on annotated <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">service accounts</a>.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Check out the <a href="https://azure.github.io/azure-workload-identity/installation.html">installation guide</a> on how to deploy the Azure AD Workload Identity webhook.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>Check out the Azure AD Workload Identity <a href="https://azure.github.io/azure-workload-identity/quick-start.html">Quick Start</a> on how to securely access Azure cloud resources from your application using the webhook and MSAL SDK.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The repository contains the following components:</p>
<ol>
<li>
<p><a href="https://azure.github.io/azure-workload-identity/concepts.html#mutating-webhook">Mutating Webhook</a></p>
<blockquote>
<p>The webhook is for mutating pods that reference an annotated service account. The webhook will inject the environment variables and the <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection">projected service account token volume</a>. Your application/SDK will consume them to authenticate itself to Azure resources.</p>
</blockquote>
</li>
<li>
<p><a href="https://azure.github.io/azure-workload-identity/concepts.html#proxy-init">Proxy Init</a> and <a href="https://azure.github.io/azure-workload-identity/concepts.html#proxy">Proxy</a></p>
<blockquote>
<p>The proxy init container and proxy sidecar container will be used for applications that are still using <a href="https://github.com/Azure/aad-pod-identity">AAD Pod Identity</a>.</p>
</blockquote>
</li>
</ol>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<ul>
<li>Cloud-agnostic.</li>
<li>Support Linux and Windows workload.</li>
<li>Industry-standard and Kubernetes-friendly authentication based on OpenID Connect (OIDC).</li>
<li>Remove convoluted steps to set up <a href="https://azure.github.io/aad-pod-identity/docs/getting-started/role-assignment/">cluster role assignments</a>.</li>
<li>Remove the following dependencies:
<ul>
<li><a href="https://docs.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service?tabs=windows">Instance Metadata Service</a> (IMDS)</li>
<li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#customresourcedefinitions">CustomResourceDefinitions</a> (CRDs)</li>
</ul>
</li>
</ul>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<ul>
<li>A secure way for cloud-native applications to obtain AAD tokens and access Azure cloud resources in a Kubernetes cluster.</li>
</ul>
<!-- - Ensure backward compatibility when upgrading from [AAD Pod Identity](https://github.com/Azure/aad-pod-identity). -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-1"><a class="header" href="#installation-1">Installation</a></h1>
<p>Obtain your Azure tenant ID by running the following command:</p>
<pre><code class="language-bash">export AZURE_TENANT_ID=&quot;$(az account show -s &lt;AzureSubscriptionID&gt; --query tenantId -otsv)&quot;
# TODO: account for different environments
export AZURE_ENVIRONMENT=&quot;AzurePublicCloud&quot;
</code></pre>
<p>The tenant ID above will be the default tenant ID that the webhook uses when configuring the <code>AZURE_TENANT_ID</code> environment variable in the pod. In the case of a multi-tenant cluster, you can override the tenant ID by adding the <code>azure.workload.identity/tenant-id</code> annotation to your service account.</p>
<h2 id="helm"><a class="header" href="#helm">Helm</a></h2>
<pre><code class="language-bash"># TODO(chewong): use https://azure.github.io/azure-workload-identity/charts
helm install workload-identity-webhook manifest_staging/charts/workload-identity-webhook \
   --namespace azure-workload-identity-system \
   --create-namespace \
   --set azureTenantID=&quot;${AZURE_TENANT_ID}&quot;
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">namespace/azure-workload-identity-system created
NAME: workload-identity-webhook
LAST DEPLOYED: Wed Aug  4 10:49:20 2021
NAMESPACE: azure-workload-identity-system
STATUS: deployed
REVISION: 1
TEST SUITE: None
</code></pre>
</details>
<h2 id="deployment-yaml"><a class="header" href="#deployment-yaml">Deployment YAML</a></h2>
<blockquote>
<p>Replace the Azure tenant ID and cloud environment name in <a href="https://github.com/Azure/azure-workload-identity/blob/1cb9d78159458b0c820c9c08fadf967833c8cdb4/deploy/azure-wi-webhook.yaml#L103-L104">here</a> before executing</p>
</blockquote>
<pre><code class="language-bash">sed -i &quot;s/AZURE_TENANT_ID: .*/AZURE_TENANT_ID: ${AZURE_TENANT_ID}/&quot; deploy/azure-wi-webhook.yaml
sed -i &quot;s/AZURE_ENVIRONMENT: .*/AZURE_ENVIRONMENT: ${AZURE_ENVIRONMENT}/&quot; deploy/azure-wi-webhook.yaml
kubectl apply -f deploy/azure-wi-webhook.yaml
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">namespace/azure-workload-identity-system created
serviceaccount/azure-wi-webhook-admin created
role.rbac.authorization.k8s.io/azure-wi-webhook-manager-role created
clusterrole.rbac.authorization.k8s.io/azure-wi-webhook-manager-role created
rolebinding.rbac.authorization.k8s.io/azure-wi-webhook-manager-rolebinding created
clusterrolebinding.rbac.authorization.k8s.io/azure-wi-webhook-manager-rolebinding created
configmap/azure-wi-webhook-config created
secret/azure-wi-webhook-server-cert created
service/azure-wi-webhook-webhook-service created
deployment.apps/azure-wi-webhook-controller-manager created
mutatingwebhookconfiguration.admissionregistration.k8s.io/azure-wi-webhook-mutating-webhook-configuration created
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h1>
<ul>
<li><a href="quick-start.html#prerequisites">Prerequisites</a></li>
<li><a href="quick-start.html#1-install-the-azure-ad-workload-identity-webhook">1. Install the Azure AD Workload Identity webhook</a></li>
<li><a href="quick-start.html#2-create-an-azure-key-vault-and-secret">2. Create an Azure Key Vault and secret</a></li>
<li><a href="quick-start.html#3-create-an-aad-application-and-grant-permissions-to-access-the-secret">3. Create an AAD application and grant permissions to access the secret</a></li>
<li><a href="quick-start.html#4-create-a-kubernetes-service-account">4. Create a Kubernetes service account</a></li>
<li><a href="quick-start.html#5-establish-trust-between-the-aad-application-and-the-service-account-issuer--subject">5. Establish trust between the AAD application and the service account issuer &amp; subject</a></li>
<li><a href="quick-start.html#6-deploy-workload">6. Deploy workload</a></li>
<li><a href="quick-start.html#6-cleanup">6. Cleanup</a></li>
</ul>
<p>In this tutorial, we will cover the basics of how to use the Azure AD Workload Identity webhook to acquire a token to access a secret in an <a href="https://azure.microsoft.com/en-us/services/key-vault/">Azure Key Vault</a>.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><a href="https://kubernetes.io/docs/tasks/tools/">kubectl</a></li>
<li><a href="https://azure.microsoft.com/en-us/">Microsoft Azure</a> account</li>
<li><a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli">Azure CLI</a></li>
<li>A Kubernetes cluster, with service account issuer URL and signing key pair set up
<ul>
<li>Check out <a href="./topics/managed-clusters.html">this section</a> if you are planning to use a managed Kubernetes cluster</li>
<li>Check out <a href="./topics/self-managed-clusters.html">this section</a> if you are planning to use a self-managed Kubernetes cluster</li>
</ul>
</li>
</ul>
<h2 id="1-install-the-azure-ad-workload-identity-webhook"><a class="header" href="#1-install-the-azure-ad-workload-identity-webhook">1. Install the Azure AD Workload Identity webhook</a></h2>
<ul>
<li><a href="../installation.html#helm">Helm</a></li>
<li><a href="../installation.html#deployment-yaml">Deployment YAML</a></li>
</ul>
<h2 id="2-create-an-azure-key-vault-and-secret"><a class="header" href="#2-create-an-azure-key-vault-and-secret">2. Create an Azure Key Vault and secret</a></h2>
<p>Create an Azure resource group:</p>
<pre><code class="language-bash">export RESOURCE_GROUP=&quot;azure-wi-webhook-test&quot;
export LOCATION=&quot;westus2&quot;
az group create --name &quot;${RESOURCE_GROUP}&quot; --location &quot;${LOCATION}&quot;
</code></pre>
<p>Create an Azure Key Vault:</p>
<pre><code class="language-bash">export KEYVAULT_NAME=&quot;azure-wi-webhook-test-$(openssl rand -hex 2)&quot;
export KEYVAULT_SECRET_NAME=&quot;my-secret&quot;
az keyvault create --resource-group &quot;${RESOURCE_GROUP}&quot; \
   --location &quot;${LOCATION}&quot; \
   --name &quot;${KEYVAULT_NAME}&quot;
</code></pre>
<p>Create a secret:</p>
<pre><code class="language-bash">az keyvault secret set --vault-name &quot;${KEYVAULT_NAME}&quot; \
   --name &quot;${KEYVAULT_SECRET_NAME}&quot; \
   --value &quot;Hello!&quot;
</code></pre>
<h2 id="3-create-an-aad-application-and-grant-permissions-to-access-the-secret"><a class="header" href="#3-create-an-aad-application-and-grant-permissions-to-access-the-secret">3. Create an AAD application and grant permissions to access the secret</a></h2>
<pre><code class="language-bash">export APPLICATION_CLIENT_ID=&quot;$(az ad sp create-for-rbac --skip-assignment --name https://test-sp --query appId -otsv)&quot;
</code></pre>
<p>Set access policy for the AAD application to access the keyvault secret:</p>
<pre><code class="language-bash">az keyvault set-policy --name &quot;${KEYVAULT_NAME}&quot; \
  --secret-permissions get \
  --spn &quot;${APPLICATION_CLIENT_ID}&quot;
</code></pre>
</details>
<h2 id="4-create-a-kubernetes-service-account"><a class="header" href="#4-create-a-kubernetes-service-account">4. Create a Kubernetes service account</a></h2>
<p>Create a Kubernetes service account and associate it with the AAD application we created in step 3:</p>
<pre><code class="language-bash">export SERVICE_ACCOUNT_NAMESPACE=&quot;default&quot;
export SERVICE_ACCOUNT_NAME=&quot;workload-identity-sa&quot;

cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    azure.workload.identity/client-id: ${APPLICATION_CLIENT_ID}
  labels:
    azure.workload.identity/use: &quot;true&quot;
  name: ${SERVICE_ACCOUNT_NAME}
  namespace: ${SERVICE_ACCOUNT_NAMESPACE}
EOF
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">serviceaccount/workload-identity-sa created
</code></pre>
</details>
<p>If the AAD application is not in the same tenant as the Kubernetes cluster, then annotate the service account with the application tenant ID.</p>
<pre><code class="language-bash">kubectl annotate sa workload-identity-sa azure.workload.identity/tenant-id=&quot;${APPLICATION_TENANT_ID}&quot; --overwrite
</code></pre>
<h2 id="5-establish-trust-between-the-aad-application-and-the-service-account-issuer--subject"><a class="header" href="#5-establish-trust-between-the-aad-application-and-the-service-account-issuer--subject">5. Establish trust between the AAD application and the service account issuer &amp; subject</a></h2>
<p>Login to <a href="https://portal.azure.com/#cloudshell/">Azure Cloud Shell</a> and run the following commands:</p>
<pre><code class="language-bash"># Get the object ID of the AAD application
export APPLICATION_OBJECT_ID=&quot;$(az ad app show --id ${APPLICATION_CLIENT_ID} --query objectId -otsv)&quot;
export SERVICE_ACCOUNT_ISSUER=&quot;&lt;Your Service Account Issuer URL&gt;&quot;
</code></pre>
<p>Add the federated identity credential:</p>
<pre><code class="language-bash">cat &lt;&lt;EOF &gt; body.json
{
  &quot;name&quot;: &quot;kubernetes-federated-credential&quot;,
  &quot;issuer&quot;: &quot;${SERVICE_ACCOUNT_ISSUER}&quot;,
  &quot;subject&quot;: &quot;system:serviceaccount:${SERVICE_ACCOUNT_NAMESPACE}:${SERVICE_ACCOUNT_NAME}&quot;,
  &quot;description&quot;: &quot;Kubernetes service account federated credential&quot;,
  &quot;audiences&quot;: [
    &quot;api://AzureADTokenExchange&quot;
  ]
}
EOF

az rest --method POST --uri &quot;https://graph.microsoft.com/beta/applications/${APPLICATION_OBJECT_ID}/federatedIdentityCredentials&quot; --body @body.json
</code></pre>
<h2 id="6-deploy-workload"><a class="header" href="#6-deploy-workload">6. Deploy workload</a></h2>
<p>Deploy a pod that references the service account created in the last step:</p>
<pre><code class="language-bash">cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: quick-start
  namespace: ${SERVICE_ACCOUNT_NAMESPACE}
spec:
  serviceAccountName: ${SERVICE_ACCOUNT_NAME}
  containers:
    - image: aramase/dotnet:v0.4
      imagePullPolicy: IfNotPresent
      name: oidc
      env:
      - name: KEYVAULT_NAME
        value: ${KEYVAULT_NAME}
      - name: SECRET_NAME
        value: ${KEYVAULT_SECRET_NAME}
  nodeSelector:
    kubernetes.io/os: linux
EOF
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">pod/quick-start created
</code></pre>
</details>
<p>To check whether all properties are injected properly by the webhook:</p>
<pre><code class="language-bash">kubectl describe pod quick-start
</code></pre>
<details>
<summary>Output</summary>
<p>You can verify the following injected properties in the output:</p>
<table><thead><tr><th>Environment variable</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AZURE_AUTHORITY_HOST</code></td><td>The Azure Active Directory (AAD) endpoint.</td></tr>
<tr><td><code>AZURE_CLIENT_ID</code></td><td>The client ID of the AAD application.</td></tr>
<tr><td><code>AZURE_TENANT_ID</code></td><td>The tenant ID of the registered AAD application.</td></tr>
<tr><td><code>AZURE_FEDERATED_TOKEN_FILE</code></td><td>The path of the projected service account token file.</td></tr>
</tbody></table>
<br/>
<table><thead><tr><th>Volume mount</th><th>Description</th></tr></thead><tbody>
<tr><td><code>/var/run/secrets/tokens/azure-identity-token</code></td><td>The path of the projected service account token file.</td></tr>
</tbody></table>
<br/>
<table><thead><tr><th>Volume</th><th>Description</th></tr></thead><tbody>
<tr><td><code>azure-identity-token</code></td><td>The projected service account volume.</td></tr>
</tbody></table>
<pre><code class="language-log">Name:         quick-start
Namespace:    default
Priority:     0
Node:         azure-workload-identity-control-plane/172.18.0.2
Start Time:   Wed, 07 Jul 2021 14:45:38 -0700
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Status:       Running
IP:           10.244.0.9
IPs:
  IP:  10.244.0.9
Containers:
  oidc:
    Container ID:   containerd://efa8d09f78dc88dd17518ce5430ea820cef5743b33d77ae2b31e1082cc439218
    Image:          aramase/dotnet:v0.4
    Image ID:       docker.io/aramase/dotnet@sha256:821dbaa070bf7e26dd9172092658f6e6f910a2db198723e10b3ebb4e35a99eb5
    Port:           &lt;none&gt;
    Host Port:      &lt;none&gt;
    State:          Running
      Started:      Wed, 07 Jul 2021 14:45:45 -0700
    Ready:          True
    Restart Count:  0
    Environment:
      KEYVAULT_NAME:              ${KEYVAULT_NAME}
      SECRET_NAME:                ${KEYVAULT_SECRET_NAME}
      AZURE_AUTHORITY_HOST:       (Injected by the webhook)
      AZURE_CLIENT_ID:            (Injected by the webhook)
      AZURE_TENANT_ID:            (Injected by the webhook)
      AZURE_FEDERATED_TOKEN_FILE: (Injected by the webhook)
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from workload-identity-sa-token-mlgn8 (ro)
      /var/run/secrets/tokens from azure-identity-token (ro) (Injected by the webhook)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  workload-identity-sa-token-mlgn8:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  workload-identity-sa-token-mlgn8
    Optional:    false
  azure-identity-token: (Injected by the webhook)
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  86400
QoS Class:                   BestEffort
Node-Selectors:              kubernetes.io/os=linux
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age    From               Message
  ----    ------     ----   ----               -------
  Normal  Scheduled  3m27s  default-scheduler  Successfully assigned default/quick-start to azure-workload-identity-control-plane
  Normal  Pulling    3m26s  kubelet            Pulling image &quot;aramase/dotnet:v0.4&quot;
  Normal  Pulled     3m21s  kubelet            Successfully pulled image &quot;aramase/dotnet:v0.4&quot; in 5.824712366s
  Normal  Created    3m20s  kubelet            Created container oidc
  Normal  Started    3m20s  kubelet            Started container oidc
</code></pre>
</details>
<p>To verify that pod is able to get a token and access the secret from the Key Vault:</p>
<pre><code class="language-bash">kubectl logs quick-start
</code></pre>
<details>
<summary>Output</summary>
<p>If successful, the log output would be similar to the following output:</p>
<pre><code class="language-bash">START 07/07/2021 21:45:45 (quick-start)
Your secret is Hello!
</code></pre>
</details>
<h2 id="6-cleanup"><a class="header" href="#6-cleanup">6. Cleanup</a></h2>
<pre><code class="language-bash">kubectl delete pod quick-start
kubectl delete sa workload-identity-sa

az group delete --name &quot;${RESOURCE_GROUP}&quot;
az ad sp delete --id &quot;${APPLICATION_CLIENT_ID}&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p><img src="./images/flow-diagram.png" alt="Flow Diagram" /></p>
<h2 id="service-account"><a class="header" href="#service-account">Service Account</a></h2>
<blockquote>
<p>“A service account provides an identity for processes that run in a Pod.” - <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">source</a></p>
</blockquote>
<p>Azure AD Workload Identity supports the following mappings:</p>
<ul>
<li>one-to-one (a service account referencing an AAD object)</li>
<li>many-to-one (multiple service accounts referencing the same AAD object).</li>
<li>one-to-many (a service account referencing multiple AAD objects by changing the <a href="../topics/service-account-labels-and-annotations.html#annotations">client ID annotation</a>).</li>
</ul>
<blockquote>
<p>Note: if the service account annotations are updated, you need to restart the pod for the changes to take effect.</p>
</blockquote>
<p>Users who used <a href="https://github.com/Azure/aad-pod-identity">aad-pod-identity</a> can think of a service account as an <a href="https://azure.github.io/aad-pod-identity/docs/concepts/azureidentity/">AzureIdentity</a>, except service account is part of the core Kubernetes API, rather than a CRD. This <a href="../topics/service-account-labels-and-annotations.html">doc</a> describes a list of available labels and annotations to configure.</p>
<h2 id="mutating-webhook"><a class="header" href="#mutating-webhook">Mutating Webhook</a></h2>
<p>Azure AD Workload Identity uses a <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">mutating admission webhook</a> to inject the following properties to pods with a service account that is configured to use Azure AD Workload Identity:</p>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<table><thead><tr><th>Environment variable</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AZURE_AUTHORITY_HOST</code></td><td>The Azure Active Directory (AAD) endpoint.</td></tr>
<tr><td><code>AZURE_CLIENT_ID</code></td><td>The client ID of the identity.</td></tr>
<tr><td><code>AZURE_TENANT_ID</code></td><td>The tenant ID of the Azure account.</td></tr>
<tr><td><code>AZURE_FEDERATED_TOKEN_FILE</code></td><td>The path of the projected service account token file.</td></tr>
</tbody></table>
<h3 id="volumes"><a class="header" href="#volumes">Volumes</a></h3>
<table><thead><tr><th>Volume</th><th>Description</th></tr></thead><tbody>
<tr><td><code>azure-identity-token</code></td><td>The projected service account volume.</td></tr>
</tbody></table>
<h3 id="volume-mounts"><a class="header" href="#volume-mounts">Volume Mounts</a></h3>
<table><thead><tr><th>Volume mount</th><th>Description</th></tr></thead><tbody>
<tr><td><code>/var/run/secrets/tokens/azure-identity-token</code></td><td>The path of the projected service account token file.</td></tr>
</tbody></table>
<p>With these properties injected, the webhook allows pods to use a <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection">service account token</a> projected to its volume to exchange for a valid AAD token using the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-overview">Microsoft Authentication Library</a> (MSAL).</p>
<h2 id="proxy-init"><a class="header" href="#proxy-init">Proxy Init</a></h2>
<p>Proxy Init is an <a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/">init container</a> that establishes an iptables rule to redirect all IMDS requests from <code>169.254.169.254</code> to the <a href="concepts.html#proxy">proxy</a> server by running the following command:</p>
<pre><code class="language-sh">PROXY_PORT=${PROXY_PORT:-8000}
METADATA_IP=${METADATA_IP:-169.254.169.254}
METADATA_PORT=${METADATA_PORT:-80}

# Forward outbound traffic for metadata endpoint to proxy
iptables -t nat -A OUTPUT -p tcp -d &quot;${METADATA_IP}&quot; --dport &quot;${METADATA_PORT}&quot; -j REDIRECT --to-port &quot;${PROXY_PORT}&quot;
</code></pre>
<h2 id="proxy"><a class="header" href="#proxy">Proxy</a></h2>
<p><img src="./images/proxy-diagram.png" alt="Proxy" /></p>
<p>Proxy is a <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar">sidecar container</a> that obtains an AAD token using MSAL on behalf of applications that are still relying on the AAD Authentication Library (ADAL), for example, <a href="https://github.com/Azure/aad-pod-identity">AAD Pod Identity</a>.</p>
<blockquote>
<p>“Starting June 30th, 2020, we will no longer add new features to ADAL. We’ll continue adding critical security fixes to ADAL until June 30th, 2022. After this date, your apps using ADAL will continue to work, but we recommend upgrading to MSAL to take advantage of the latest features and to stay secure.” - <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-migration#frequently-asked-questions-faq">source</a></p>
</blockquote>
<p>All IMDS requests from the container are routed to this proxy server due to an existing iptables rule created by <a href="concepts.html#proxy-init">Proxy Init</a>.</p>
<h2 id="trust"><a class="header" href="#trust">Trust</a></h2>
<p>Not all service account tokens can be exchanged for a valid AAD token. Trust between an existing service account and an AAD application has to be established in advance.</p>
<p>To establish trust, login to <a href="https://portal.azure.com/#cloudshell/">Azure Cloud Shell</a> and export the following environment variables:</p>
<pre><code class="language-bash"># Get the client and object ID of the AAD application
export APPLICATION_CLIENT_ID=&quot;...&quot;
export APPLICATION_OBJECT_ID=&quot;$(az ad app show --id ${APPLICATION_CLIENT_ID} --query objectId -otsv)&quot;
export SERVICE_ACCOUNT_ISSUER=&quot;...&quot;
export SERVICE_ACCOUNT_NAMESPACE=&quot;...&quot;
export SERVICE_ACCOUNT_NAME=&quot;...&quot;
</code></pre>
<p>Add the federated identity credential:</p>
<pre><code class="language-bash">cat &lt;&lt;EOF &gt; body.json
{
  &quot;name&quot;: &quot;kubernetes-federated-credential&quot;,
  &quot;issuer&quot;: &quot;${SERVICE_ACCOUNT_ISSUER}&quot;,
  &quot;subject&quot;: &quot;system:serviceaccount:${SERVICE_ACCOUNT_NAMESPACE}:${SERVICE_ACCOUNT_NAME}&quot;,
  &quot;description&quot;: &quot;Kubernetes service account federated credential&quot;,
  &quot;audiences&quot;: [
    &quot;api://AzureADTokenExchange&quot;
  ]
}
EOF

az rest --method POST --uri &quot;https://graph.microsoft.com/beta/applications/${APPLICATION_OBJECT_ID}/federatedIdentityCredentials&quot; --body @body.json
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topics"><a class="header" href="#topics">Topics</a></h1>
<p>This section contains information about enabling and configuring various features with Azure AD Workload Identity. We strongly recommend users to go through each applicable topic in order, from setting up your Kubernetes clusters, performing various tasks for self-managed clusters, to leveraging the webhook in your application to securely access Azure cloud resources.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managed-clusters"><a class="header" href="#managed-clusters">Managed Clusters</a></h1>
<h2 id="azure-kubernetes-service-aks"><a class="header" href="#azure-kubernetes-service-aks">Azure Kubernetes Service (AKS)</a></h2>
<h2 id="amazon-elastic-kubernetes-service-eks"><a class="header" href="#amazon-elastic-kubernetes-service-eks">Amazon Elastic Kubernetes Service (EKS)</a></h2>
<h2 id="google-kubernetes-engine-gke"><a class="header" href="#google-kubernetes-engine-gke">Google Kubernetes Engine (GKE)</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-managed-clusters"><a class="header" href="#self-managed-clusters">Self-Managed Clusters</a></h1>
<p>When compared to using managed Kubernetes services like AKS, managing your own Kubernetes cluster provides the most freedom in customizing Kubernetes and your workload. Make sure the cluster administrator can perform the following actions before deploying the Azure AD Workload Identity webhook to a self-managed cluster:</p>
<ul>
<li>Access to the cluster’s control plane node(s)</li>
<li>Ability to modify arguments for system-critical pods such as kube-apiserver and kube-controller-manager</li>
<li>Bring your own service account signing key pair and rotate it regularly (at least quarterly)</li>
<li>Upload your OIDC discovery document and JWK to a public storage endpoint</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://capz.sigs.k8s.io/">Cluster API Provider Azure</a> (CAPZ)</td><td>Cluster API implementation for Microsoft Azure.</td></tr>
<tr><td><a href="https://anywhere.eks.amazonaws.com/">Amazon EKS Anywhere</a></td><td>Run Amazon EKS on your own infrastructure.</td></tr>
<tr><td><a href="https://kind.sigs.k8s.io/">Kubernetes in Docker</a> (kind)</td><td>Run local Kubernetes clusters using Docker container. A fast way to create a conformant Kubernetes cluster. Great for local testing and development.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-account-key-rotation"><a class="header" href="#service-account-key-rotation">Service Account Key Rotation</a></h1>
<ul>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#best-practices">Best Practices</a>
<ul>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#key-rotation">Key rotation</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#key-retirement">Key retirement</a></li>
</ul>
</li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#steps-to-manually-generate-and-rotate-keys">Steps to manually generate and rotate keys</a>
<ul>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#1-generate-a-new-key-pair">1. Generate a new key pair</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#2-backup-the-old-key-pair-and-distribute-the-new-key-pair">2. Backup the old key pair and distribute the new key pair</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#3-update-the-jwks">3. Update the JWKS</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#4-key-rotation">4. Key Rotation</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#5-verification">5. Verification</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#6-cleanup">6. Cleanup</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#7-remove-old-jwk-after-maximum-token-expiration">7. Remove old JWK after maximum token expiration</a></li>
</ul>
</li>
</ul>
<p>A security best practice is to routinely rotate your key pair used to sign the service account tokens. This page explains the best practices, guidelines, as well as how to generate and rotate it in the case of self-managed Kubernetes clusters where you have access to the control plane.</p>
<blockquote>
<p>This technique requires that the Kubernetes control plane is running in a high-availability (HA) setup with multiple API servers. Clusters that use a single API server will become unavailable while the API server is restarted.</p>
</blockquote>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="key-rotation"><a class="header" href="#key-rotation">Key rotation</a></h3>
<p>Key pair should be rotated on a regular basis. For references, AKS clusters rotate their service account signing key pairs <strong>every three months</strong>.</p>
<h3 id="key-retirement"><a class="header" href="#key-retirement">Key retirement</a></h3>
<p>Key pair should be retired when they are no longer needed. In most cases, this means permanently removing them to guarantee that it poses no more risk and to minimize the number of active key pairs that are being handled.</p>
<h2 id="steps-to-manually-generate-and-rotate-keys"><a class="header" href="#steps-to-manually-generate-and-rotate-keys">Steps to manually generate and rotate keys</a></h2>
<h3 id="1-generate-a-new-key-pair"><a class="header" href="#1-generate-a-new-key-pair">1. Generate a new key pair</a></h3>
<blockquote>
<p>Skip this step if you are planning to bring your own keys.</p>
</blockquote>
<pre><code class="language-bash">openssl genrsa -out sa-new.key 2048
openssl rsa -in sa-new.key -pubout -out sa-new.pub
</code></pre>
<h3 id="2-backup-the-old-key-pair-and-distribute-the-new-key-pair"><a class="header" href="#2-backup-the-old-key-pair-and-distribute-the-new-key-pair">2. Backup the old key pair and distribute the new key pair</a></h3>
<p>Schedule a jump pod to each control plane node, which mounts the <code>/etc/kubernetes/pki</code> folder:</p>
<blockquote>
<p><code>/etc/kubernetes/pki/sa.pub</code> and <code>/etc/kubernetes/pki/sa.key</code> are the paths of the service account key pair for a kind cluster. The paths can vary depending on your provider.</p>
</blockquote>
<pre><code class="language-bash">cat &lt;&lt; EOF | kubectl apply -f -
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: jump
  labels:
    k8s-app: jump
spec:
  selector:
    matchLabels:
      name: jump
  template:
    metadata:
      labels:
        name: jump
    spec:
      tolerations:
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule
      containers:
        - name: busybox
          image: busybox
          command:
            - sleep
            - &quot;3600&quot;
          volumeMounts:
              - mountPath: /etc/kubernetes/pki
                name: etc-kubernetes-pki
      volumes:
        - name: etc-kubernetes-pki
          hostPath:
            path: /etc/kubernetes/pki
EOF
</code></pre>
<p>Backup the old service account key pair to your local machine:</p>
<pre><code class="language-bash">POD_NAME=&quot;$(kubectl get po -l name=jump -ojson | jq -r '.items[0].metadata.name')&quot;
kubectl cp default/${POD_NAME}:/etc/kubernetes/pki/sa.pub sa-old.pub
kubectl cp default/${POD_NAME}:/etc/kubernetes/pki/sa.key sa-old.key
</code></pre>
<p>Distribute the new key pair to the certificate directory of each control plane node:</p>
<pre><code class="language-bash">for POD_NAME in &quot;$(kubectl get po -l name=jump -ojson | jq -r '.items[].metadata.name')&quot;; do
  kubectl cp sa-new.pub default/${POD_NAME}:/etc/kubernetes/pki/sa-new.pub
  kubectl cp sa-new.key default/${POD_NAME}:/etc/kubernetes/pki/sa-new.key
done
</code></pre>
<h3 id="3-update-the-jwks"><a class="header" href="#3-update-the-jwks">3. Update the JWKS</a></h3>
<p>In the case of service account tokens generated before you initiated the key rotation, you would need a time period where the old and new public keys exist in the JWKS. The relying party can then validate service account tokens signed by both the old and new private key.</p>
<p>Install the <code>generate-jwks</code> tool:</p>
<blockquote>
<p>Make sure the environment variable <code>GOBIN</code> is defined and it is part of your <code>PATH</code>.</p>
</blockquote>
<pre><code class="language-bash">pushd hack/generate-jwks
go install .
popd
</code></pre>
<p>Generate and upload the JWKS:</p>
<blockquote>
<p>Assuming you followed our <a href="topics/self-managed-clusters/../../quick-start.html">Quick Start</a> and store your OIDC discovery document and JWKS in an Azure storage account.</p>
</blockquote>
<pre><code class="language-bash">generate-jwks --public-keys sa-old.pub,sa-new.pub &gt; jwks.json
export AZURE_STORAGE_ACCOUNT=&lt;AzureStorageAccount&gt;
az storage blob upload \
  --container-name &quot;${AZURE_STORAGE_CONTAINER}&quot; \
  --file jwks.json \
  --name openid/v1/jwks
</code></pre>
<h3 id="4-key-rotation"><a class="header" href="#4-key-rotation">4. Key Rotation</a></h3>
<p>With the new key pair distributed, you can utilize <a href="https://github.com/kvaps/kubectl-node-shell">kubectl-node-shell</a> to update the following core components arguments by spawning a root shell to each control plane node:</p>
<pre><code class="language-bash">kubectl node-shell &lt;NodeName&gt;

# Run in the root shell
# download yq (jq for yaml)
curl -L https://github.com/mikefarah/yq/releases/download/v4.12.1/yq_linux_amd64 --output /usr/bin/yq
chmod +x /usr/bin/yq

# append the new public key as an kube-apiserver argument
yq eval -i '.spec.containers[0].command |= . + [&quot;--service-account-key-file=/etc/kubernetes/pki/sa-new.pub&quot;]' /etc/kubernetes/manifests/kube-apiserver.yaml

# replace the old private key with the new private key for kube-apiserver and kube-controller-manager
sed -i 's|--service-account-signing-key-file=.*|--service-account-signing-key-file=/etc/kubernetes/pki/sa-new.key|' /etc/kubernetes/manifests/kube-apiserver.yaml
sed -i 's|--service-account-private-key-file=.*|--service-account-private-key-file=/etc/kubernetes/pki/sa-new.key|' /etc/kubernetes/manifests/kube-controller-manager.yaml
</code></pre>
<p>The commands above should trigger a restart for kube-apiserver and kube-controller-manager pod.</p>
<h3 id="5-verification"><a class="header" href="#5-verification">5. Verification</a></h3>
<p>Create a dummy pod that uses an annotated service account.</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | kubectl apply -f -
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    azure.workload.identity/client-id: dummy
  labels:
    azure.workload.identity/use: &quot;true&quot;
  name: workload-identity-sa
---
apiVersion: v1
kind: Pod
metadata:
  name: dummy-pod
spec:
  serviceAccountName: workload-identity-sa
  containers:
    - name: busybox
      image: busybox
      command:
        - sleep
        - &quot;3600&quot;
EOF
</code></pre>
<p>Output the projected service account token:</p>
<pre><code class="language-bash">kubectl exec dummy-pod -- cat /var/run/secrets/tokens/azure-identity-token
</code></pre>
<p>Decode your token using <a href="https://jwt.io/">jwt.io</a>. The <code>kid</code> field in the token header should be the same as the <code>kid</code> of <code>generate-jwks --public-keys sa-new.pub | jq -r '.keys[0].kid'</code>. This means that the service account token is signed by the new private key.</p>
<h3 id="6-cleanup-1"><a class="header" href="#6-cleanup-1">6. Cleanup</a></h3>
<p>Delete the dangling resources created above:</p>
<pre><code class="language-bash">kubectl delete ds jump
kubectl delete pod dummy-pod
kubectl delete sa workload-identity-sa
</code></pre>
<h3 id="7-remove-old-jwk-after-maximum-token-expiration"><a class="header" href="#7-remove-old-jwk-after-maximum-token-expiration">7. Remove old JWK after maximum token expiration</a></h3>
<p>After the maximum token expiration (the default expiration is 24 hours) has passed, projected service account tokens signed by the old private key will be rotated by kubelet and signed with the new signing key. The kubelet proactively rotates the token if it is older than 80% of its total TTL, or if the token is older than 24 hours. You should update the JWKS accordingly to only include the new public key:</p>
<pre><code class="language-bash">generate-jwks --public-keys sa-new.pub | jq &gt; jwks.json
az storage blob upload \
  --container-name &quot;${AZURE_STORAGE_CONTAINER}&quot; \
  --file jwks.json \
  --name openid/v1/jwks
</code></pre>
<p>Remove the old public key from kube-apiserver’s arguments:</p>
<pre><code class="language-bash"># get the index of the old public key from the kube-apiserver argument array
INDEX=&quot;$(yq e '.spec.containers[0].command' /etc/kubernetes/manifests/kube-apiserver.yaml | grep -Fn 'service-account-key-file' | head -n 1 | cut -d':' -f1)&quot;

# convert to zero-index
INDEX=&quot;$(expr ${INDEX} - 1)&quot;

# remove the old public key argument using yq
yq eval -i &quot;del(.spec.containers[0].command[${INDEX}])&quot; /etc/kubernetes/manifests/kube-apiserver.yaml

# remove the old key pair from disk
rm sa.*
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-account-labels-and-annotations"><a class="header" href="#service-account-labels-and-annotations">Service Account Labels and Annotations</a></h1>
<p>The following is a list of available labels and annotations that can be used to configure the behavior when obtaining an AAD token via MSAL.</p>
<h2 id="service-account-1"><a class="header" href="#service-account-1">Service Account</a></h2>
<h3 id="labels"><a class="header" href="#labels">Labels</a></h3>
<table><thead><tr><th>Label</th><th>Description</th><th>Recommended value</th><th>Required?</th></tr></thead><tbody>
<tr><td><code>azure.workload.identity/use</code></td><td>Represents the service account is to be used for workload identity.</td><td><code>true</code></td><td>✓</td></tr>
</tbody></table>
<h3 id="annotations"><a class="header" href="#annotations">Annotations</a></h3>
<table><thead><tr><th>Annotation</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>azure.workload.identity/client-id</code></td><td>Represents the AAD application client ID to be used with the pod.</td><td></td></tr>
<tr><td><code>azure.workload.identity/tenant-id</code></td><td>Represents the Azure tenant ID where the AAD application is registered.</td><td><code>AZURE_TENANT_ID</code> environment variable extracted from <a href="https://github.com/Azure/azure-workload-identity/blob/1f4c734cfad7f0653601aa375daf4d32ef0cb5d2/manifest_staging/deploy/aad-pi-webhook.yaml#L43-L52"><code>aad-pi-webhook-config</code></a> ConfigMap</td></tr>
<tr><td><code>azure.workload.identity/service-account-token-expiration</code></td><td>Represents the <code>expirationSeconds</code> field for the projected service account token. It is an optional field that the user might want to configure this to prevent any downtime caused by errors during service account token refresh. Kubernetes service account token expiry will not be correlated with AAD tokens. AAD tokens will expire in 24 hours after they are issued.</td><td><code>86400</code> (minimum <code>3600</code>)</td></tr>
</tbody></table>
<h2 id="pod"><a class="header" href="#pod">Pod</a></h2>
<h3 id="annotations-1"><a class="header" href="#annotations-1">Annotations</a></h3>
<table><thead><tr><th>Annotation</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>azure.workload.identity/service-account-token-expiration</code></td><td><strong>(Takes precedence if the service account is also annotated)</strong> Represents the <code>expirationSeconds</code> field for the projected service account token. It is an optional field that the user might want to configure this to prevent any downtime caused by errors during service account token refresh. Kubernetes service account token expiry will not be correlated with AAD tokens. AAD tokens will expire in 24 hours after they are issued.</td><td><code>86400</code> (minimum <code>3600</code>)</td></tr>
<tr><td><code>azure.workload.identity/skip-containers</code></td><td>Represents a semi-colon-separated list of containers (e.g. <code>container1;container2</code>) to skip adding projected service account token volume. By default, the projected service account token volume will be added to all containers if the service account is labeled with <code>azure.workload.identity/use: true</code>.</td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h1>
<h2 id="permission-denied-when-reading-the-projected-service-account-token-file"><a class="header" href="#permission-denied-when-reading-the-projected-service-account-token-file">Permission denied when reading the projected service account token file</a></h2>
<p>In Kubernetes 1.18, the default mode for the projected service account token file is <code>0600</code>. This causes containers running as non-root to fail while trying to read the token file:</p>
<pre><code class="language-bash">F0826 20:03:20.113998 1 main.go:27] failed to get secret from keyvault, err: autorest/Client#Do: Preparing request failed: StatusCode=0 -- Original Error: failed to read service account token: open /var/run/secrets/tokens/azure-identity-token: permission denied
</code></pre>
<p>The default mode was changed to <code>0644</code> in Kubernetes v1.19, which allows containers running as non-root to read the projected service account token.</p>
<p>If you ran into this issue, you can either:</p>
<ol>
<li>
<p>Upgrade your cluster to v1.19+ or</p>
</li>
<li>
<p>Apply the following <code>securityContext</code> field to your pod spec:</p>
</li>
</ol>
<pre><code class="language-yaml">spec:
  securityContext:
    fsGroup: 65534
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">Development</a></h1>
<ul>
<li><a href="development.html#setting-up">Setting up</a>
<ul>
<li><a href="development.html#base-requirements">Base requirements</a></li>
<li><a href="development.html#clone-the-repository">Clone the repository</a></li>
</ul>
</li>
<li><a href="development.html#create-a-test-cluster">Create a test cluster</a>
<ul>
<li><a href="development.html#generate-a-custom-publicprivate-key-pair">Generate a custom public/private key pair</a></li>
<li><a href="development.html#setup-the-oidc-discovery-document-and-jwks">Setup the OIDC discovery document and JWKS</a></li>
<li><a href="development.html#create-a-kind-cluster">Create a kind cluster</a></li>
</ul>
</li>
<li><a href="development.html#build-and-deploy-the-webhook">Build and deploy the webhook</a></li>
<li><a href="development.html#unit-test">Unit Test</a></li>
<li><a href="development.html#e2e-test">E2E Test</a></li>
</ul>
<h2 id="setting-up"><a class="header" href="#setting-up">Setting up</a></h2>
<h3 id="base-requirements"><a class="header" href="#base-requirements">Base requirements</a></h3>
<ol>
<li>Prerequisites from <a href="./quick-start.html#prerequisites">Quick Start</a></li>
<li>Install <a href="https://golang.org/dl/">go</a>
<ul>
<li>Get the latest patch version for go 1.17.</li>
</ul>
</li>
<li>Install <a href="https://stedolan.github.io/jq/">jq</a>
<ul>
<li><code>brew install jq</code> on macOS.</li>
<li><code>chocolatey install jq</code> on Windows.</li>
<li><code>sudo apt install jq</code> on Ubuntu Linux.</li>
</ul>
</li>
<li>Install make.</li>
</ol>
<h3 id="clone-the-repository"><a class="header" href="#clone-the-repository">Clone the repository</a></h3>
<pre><code class="language-bash">git clone https://github.com/Azure/azure-workload-identity.git $(go env GOPATH)/src/github.com/Azure/azure-workload-identity
</code></pre>
<h2 id="create-a-test-cluster"><a class="header" href="#create-a-test-cluster">Create a test cluster</a></h2>
<h3 id="generate-a-custom-publicprivate-key-pair"><a class="header" href="#generate-a-custom-publicprivate-key-pair">Generate a custom public/private key pair</a></h3>
<blockquote>
<p>Skip this step if you are planning to bring your own keys.</p>
</blockquote>
<pre><code class="language-bash">openssl genrsa -out sa.key 2048
openssl rsa -in sa.key -pubout -out sa.pub
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">Generating RSA private key, 2048 bit long modulus
..............+++
......+++
e is 65537 (0x10001)
writing RSA key
</code></pre>
</details>
<h3 id="setup-the-oidc-discovery-document-and-jwks"><a class="header" href="#setup-the-oidc-discovery-document-and-jwks">Setup the OIDC discovery document and JWKS</a></h3>
<blockquote>
<p>Skip this step if you already set up the OIDC discovery document and JWKS.</p>
</blockquote>
<p>Azure blob storage will be used to host the OIDC discovery document and JWKS. However, you can host them in anywhere, as long as they are publicly available.</p>
<pre><code class="language-bash">export AZURE_STORAGE_ACCOUNT=&quot;pmi$(openssl rand -hex 4)&quot;
export AZURE_STORAGE_CONTAINER=&quot;oidc-test&quot;
az storage account create --resource-group &quot;${RESOURCE_GROUP}&quot; --name &quot;${AZURE_STORAGE_ACCOUNT}&quot;
az storage container create --name &quot;${AZURE_STORAGE_CONTAINER}&quot; --public-access container
</code></pre>
<p>Generate and upload the OIDC discovery document:</p>
<pre><code class="language-bash">cat &lt;&lt;EOF &gt; openid-configuration.json
{
  &quot;issuer&quot;: &quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/&quot;,
  &quot;authorization_endpoint&quot;: &quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/connect/authorize&quot;,
  &quot;jwks_uri&quot;: &quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/openid/v1/jwks&quot;,
  &quot;response_types_supported&quot;: [
    &quot;id_token&quot;
  ],
  &quot;subject_types_supported&quot;: [
    &quot;public&quot;
  ],
  &quot;id_token_signing_alg_values_supported&quot;: [
    &quot;RS256&quot;
  ]
}
EOF
az storage blob upload \
  --container-name &quot;${AZURE_STORAGE_CONTAINER}&quot; \
  --file openid-configuration.json \
  --name .well-known/openid-configuration
</code></pre>
<p>Install the <code>generate-jwks</code> tool:</p>
<blockquote>
<p>Make sure the environment variable <code>GOBIN</code> is defined and it is part of your <code>PATH</code>.</p>
</blockquote>
<pre><code class="language-bash">pushd hack/generate-jwks
go install .
popd
</code></pre>
<p>Generate and upload the JWKS:</p>
<pre><code class="language-bash">generate-jwks --public-keys sa.pub &gt; jwks.json
az storage blob upload \
  --container-name &quot;${AZURE_STORAGE_CONTAINER}&quot; \
  --file jwks.json \
  --name openid/v1/jwks
</code></pre>
<p>Verify that the OIDC discovery document is publicly accessible:</p>
<pre><code class="language-bash">curl -s &quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/.well-known/openid-configuration&quot;
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-json">{
  &quot;issuer&quot;: &quot;https://&lt;REDACTED&gt;.blob.core.windows.net/oidc-test/&quot;,
  &quot;authorization_endpoint&quot;: &quot;https://&lt;REDACTED&gt;.blob.core.windows.net/oidc-test/connect/authorize&quot;,
  &quot;jwks_uri&quot;: &quot;https://&lt;REDACTED&gt;.blob.core.windows.net/oidc-test/openid/v1/jwks&quot;,
  &quot;response_types_supported&quot;: [
    &quot;id_token&quot;
  ],
  &quot;subject_types_supported&quot;: [
    &quot;public&quot;
  ],
  &quot;id_token_signing_alg_values_supported&quot;: [
    &quot;RS256&quot;
  ]
}
</code></pre>
</details>
<h3 id="create-a-kind-cluster"><a class="header" href="#create-a-kind-cluster">Create a kind cluster</a></h3>
<p>Export the following environment variables:</p>
<pre><code class="language-bash">export SERVICE_ACCOUNT_ISSUER=&quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/&quot;
export SERVICE_ACCOUNT_KEY_FILE=&quot;$(pwd)/sa.pub&quot;
export SERVICE_ACCOUNT_SIGNING_KEY_FILE=&quot;$(pwd)/sa.key&quot;
</code></pre>
<p>Create a kind cluster with one control plane node and customize various service account-related flags for the API server:</p>
<blockquote>
<p>The minimum supported Kubernetes version for the webhook is v1.18.0, however, we recommend using Kubernetes version v1.20.0+.</p>
</blockquote>
<pre><code class="language-bash">cat &lt;&lt;EOF | kind create cluster --name azure-workload-identity --image kindest/node:v1.21.1 --config=-
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  extraMounts:
    - hostPath: ${SERVICE_ACCOUNT_KEY_FILE}
      containerPath: /etc/kubernetes/pki/sa.pub
    - hostPath: ${SERVICE_ACCOUNT_SIGNING_KEY_FILE}
      containerPath: /etc/kubernetes/pki/sa.key
  kubeadmConfigPatches:
  - |
    kind: ClusterConfiguration
    apiServer:
      extraArgs:
        service-account-issuer: ${SERVICE_ACCOUNT_ISSUER}
        service-account-key-file: /etc/kubernetes/pki/sa.pub
        service-account-signing-key-file: /etc/kubernetes/pki/sa.key
EOF
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">Creating cluster &quot;azure-workload-identity&quot; ...
 • Ensuring node image (kindest/node:v1.21.1) 🖼  ...
 ✓ Ensuring node image (kindest/node:v1.21.1) 🖼
 • Preparing nodes 📦   ...
 ✓ Preparing nodes 📦
 • Writing configuration 📜  ...
 ✓ Writing configuration 📜
 • Starting control-plane 🕹️  ...
 ✓ Starting control-plane 🕹️
 • Installing CNI 🔌  ...
 ✓ Installing CNI 🔌
 • Installing StorageClass 💾  ...
 ✓ Installing StorageClass 💾
Set kubectl context to &quot;kind-azure-workload-identity&quot;
You can now use your cluster with:

kubectl cluster-info --context kind-azure-workload-identity

Have a question, bug, or feature request? Let us know! https://kind.sigs.k8s.io/#community 🙂
</code></pre>
</details>
<p>Run the following command to verify that the kind cluster is online:</p>
<pre><code class="language-bash">kubectl get nodes
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">NAME                                     STATUS   ROLES                  AGE     VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE       KERNEL-VERSION     CONTAINER-RUNTIME
azure-workload-identity-control-plane   Ready    control-plane,master   2m28s   v1.21.1   172.18.0.2    &lt;none&gt;        Ubuntu 21.04   5.4.0-1047-azure   containerd://1.5.2
</code></pre>
</details>
<h2 id="build-and-deploy-the-webhook"><a class="header" href="#build-and-deploy-the-webhook">Build and deploy the webhook</a></h2>
<pre><code class="language-bash">export REGISTRY=&lt;YourPublicRegistry&gt;
export IMAGE_VERSION=&quot;$(git describe --tags --always)&quot;
export AZURE_TENANT_ID=&quot;...&quot;
ALL_IMAGES=webhook make clean docker-build docker-push-manifest deploy
</code></pre>
<h2 id="unit-test"><a class="header" href="#unit-test">Unit Test</a></h2>
<pre><code class="language-bash">make test
</code></pre>
<h2 id="e2e-test"><a class="header" href="#e2e-test">E2E Test</a></h2>
<pre><code class="language-bash">make test-e2e-run
</code></pre>
<p>Optional settings are:</p>
<table><thead><tr><th>Environment variables</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>GINKGO_FOCUS</code></td><td>Allow you to focus on a subset of specs using regex.</td><td></td></tr>
<tr><td><code>GINKGO_SKIP</code></td><td>Allow you to skip a subset of specs using regex.</td><td></td></tr>
<tr><td><code>GINKGO_NODES</code></td><td>The number of ginkgo workers to run the specs.</td><td><code>3</code></td></tr>
<tr><td><code>GINKGO_NO_COLOR</code></td><td>True if you want colorized output.</td><td><code>false</code></td></tr>
<tr><td><code>GINKGO_TIMEOUT</code></td><td>The test suite timeout duration.</td><td><code>5m</code></td></tr>
<tr><td><code>KUBECONFIG</code></td><td>The cluster KUBECONFIG you want to run the e2e test against.</td><td><code>${HOME}/.kube/config</code></td></tr>
<tr><td><code>E2E_EXTRA_ARGS</code></td><td>Allow you to insert extra arguments when executing the test suite.</td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="releasing"><a class="header" href="#releasing">Releasing</a></h1>
<ul>
<li><a href="development/releasing.html#1-create-a-release-pull-request">1. Create a release pull request</a></li>
<li><a href="development/releasing.html#2-review-and-approve-the-release-pull-request">2. Review and approve the release pull request</a></li>
<li><a href="development/releasing.html#3-verify-that-the-create_tag-action-is-triggered-after-the-release-pull-request-is-merged">3. Verify that the create_tag action is triggered after the release pull request is merged</a></li>
<li><a href="development/releasing.html#4-verify-that-the-tag-is-successfully-created">4. Verify that the tag is successfully created</a></li>
</ul>
<p>We use GitHub Actions to automate our release process.</p>
<h2 id="1-create-a-release-pull-request"><a class="header" href="#1-create-a-release-pull-request">1. Create a release pull request</a></h2>
<p><img src="development/../images/release-step-1.png" alt="Create a release pull request" /></p>
<h2 id="2-review-and-approve-the-release-pull-request"><a class="header" href="#2-review-and-approve-the-release-pull-request">2. Review and approve the release pull request</a></h2>
<p><img src="development/../images/release-step-2.png" alt="Review and approve the release pull request" /></p>
<h2 id="3-verify-that-the-create_tag-action-is-triggered-after-the-release-pull-request-is-merged"><a class="header" href="#3-verify-that-the-create_tag-action-is-triggered-after-the-release-pull-request-is-merged">3. Verify that the create_tag action is triggered after the release pull request is merged</a></h2>
<p><img src="development/../images/release-step-3.png" alt="Verify that the create_tag action is triggered after the release pull request is merged" /></p>
<h2 id="4-verify-that-the-tag-is-successfully-created"><a class="header" href="#4-verify-that-the-tag-is-successfully-created">4. Verify that the tag is successfully created</a></h2>
<p><img src="development/../images/release-step-4.png" alt="Verify that the tag is successfully created" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>The Azure AD Workload Identity project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit <a href="https://cla.microsoft.com">https://cla.microsoft.com</a>.</p>
<p>When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h1>
<p>This project has adopted the <a href="https://opensource.microsoft.com/codeofconduct/">Microsoft Open Source Code of Conduct</a>. For more information, see the <a href="https://opensource.microsoft.com/codeofconduct/faq">Code of Conduct FAQ</a> or contact <a href="mailto:opencode@microsoft.com">opencode@microsoft.com</a> with any additional questions or comments.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
